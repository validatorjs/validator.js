// Demonstration of CVE-2025-56200 vulnerability analysis
// This shows how the code WOULD behave based on the source

console.log('CVE-2025-56200 Vulnerability Analysis');
console.log('=' .repeat(80));

// Simulate the vulnerable code behavior
function simulateVulnerableIsURL(url) {
  // Line 86 from isURL.js: split = url.split('://');
  let split = url.split('://');

  if (split.length > 1) {
    const protocol = split.shift().toLowerCase();
    return {
      hasProtocol: true,
      protocol: protocol,
      remainder: split.join('://'),
      interpretation: `Protocol detected: '${protocol}'`
    };
  } else {
    return {
      hasProtocol: false,
      protocol: null,
      remainder: url,
      interpretation: 'No protocol detected (no ://) - treated as host/path'
    };
  }
}

// Simulate browser parsing
function simulateBrowserParse(url) {
  const colonIndex = url.indexOf(':');
  if (colonIndex > 0) {
    const protocol = url.substring(0, colonIndex).toLowerCase();
    return {
      hasProtocol: true,
      protocol: protocol,
      remainder: url.substring(colonIndex + 1),
      interpretation: `Browser protocol: '${protocol}:'`
    };
  }
  return {
    hasProtocol: false,
    protocol: null,
    remainder: url,
    interpretation: 'No protocol (relative URL)'
  };
}

const dangerousUrls = [
  { url: 'javascript:alert(1)', description: 'XSS: javascript protocol' },
  { url: 'javascript:alert(document.cookie)', description: 'XSS: cookie theft' },
  { url: 'javascript://example.com//%0aalert(1)', description: 'XSS: obfuscated' },
  { url: 'data:text/html,<script>alert(1)</script>', description: 'XSS: data URI' },
  { url: 'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==', description: 'XSS: base64 data URI' },
  { url: 'vbscript:msgbox(1)', description: 'XSS: VBScript (legacy IE)' },
  { url: 'file:///etc/passwd', description: 'File disclosure' },
  { url: 'file:///c:/windows/system.ini', description: 'File disclosure (Windows)' },
];

const legitimateUrls = [
  { url: 'http://example.com', description: 'HTTP URL' },
  { url: 'https://example.com', description: 'HTTPS URL' },
  { url: 'ftp://example.com', description: 'FTP URL' },
];

console.log('\n1. DANGEROUS URLS - Showing the vulnerability');
console.log('-' .repeat(80));

dangerousUrls.forEach(({ url, description }) => {
  const validatorParse = simulateVulnerableIsURL(url);
  const browserParse = simulateBrowserParse(url);

  console.log(`\nURL: ${url}`);
  console.log(`Description: ${description}`);
  console.log(`  validator.js parsing: ${validatorParse.interpretation}`);
  console.log(`  Browser parsing:      ${browserParse.interpretation}`);

  if (validatorParse.hasProtocol !== browserParse.hasProtocol) {
    console.log(`  ⚠️  VULNERABILITY: Mismatch in protocol detection!`);
    console.log(`      validator.js thinks: ${validatorParse.hasProtocol ? 'HAS protocol' : 'NO protocol'}`);
    console.log(`      Browser thinks:      ${browserParse.hasProtocol ? 'HAS protocol' : 'NO protocol'}`);
    console.log(`      🔥 This URL could bypass validation and execute as ${browserParse.protocol}:`);
  }
});

console.log('\n\n2. LEGITIMATE URLS - These parse correctly');
console.log('-' .repeat(80));

legitimateUrls.forEach(({ url, description }) => {
  const validatorParse = simulateVulnerableIsURL(url);
  const browserParse = simulateBrowserParse(url);

  console.log(`\nURL: ${url}`);
  console.log(`Description: ${description}`);
  console.log(`  validator.js: ${validatorParse.interpretation}`);
  console.log(`  Browser:      ${browserParse.interpretation}`);
  console.log(`  ✓ Match: Both see protocol '${validatorParse.protocol}'`);
});

console.log('\n\n3. ROOT CAUSE ANALYSIS');
console.log('=' .repeat(80));
console.log(`
The vulnerability exists at line 86 of /Users/laptopname/validator.js/src/lib/isURL.js:

    split = url.split('://');

This splits on '://' (colon + two slashes) instead of just ':' (colon).

RFC 3986 (URI Generic Syntax) defines a URI as:
    scheme ":" hier-part [ "?" query ] [ "#" fragment ]

The scheme (protocol) is separated by a single colon ':', not '://'.
The '//' is part of the hier-part for authority-based URIs, but not all URIs use it.

Examples:
- 'http://example.com'  → scheme: 'http', hier-part: '//example.com'
- 'javascript:alert(1)' → scheme: 'javascript', hier-part: 'alert(1)' (no //)
- 'data:text/html,...'  → scheme: 'data', hier-part: 'text/html,...' (no //)
- 'file:///path'        → scheme: 'file', hier-part: '///path'

IMPACT:
-------
When validator.js uses '://' as the delimiter:
1. 'javascript:alert(1)' → split.length = 1 (no '://')
   → validator.js: NO protocol detected, may treat as valid hostname
   → Browser: 'javascript:' protocol detected, executes JavaScript

2. An attacker can bypass protocol validation because:
   - If require_valid_protocol = true and protocols = ['http', 'https', 'ftp']
   - URL 'javascript:alert(1)' has no '://' so no protocol is extracted
   - Validation skips protocol check (no protocol detected)
   - URL passes validation
   - Browser executes javascript: resulting in XSS

3. This enables:
   - Cross-Site Scripting (XSS) attacks
   - Open redirect attacks
   - Protocol confusion attacks
   - Potential SSRF in some contexts
`);

console.log('\n4. THE FIX');
console.log('=' .repeat(80));
console.log(`
Change line 86 from:
    split = url.split('://');

To parse the protocol correctly according to RFC 3986:
    // Extract protocol using ':' as delimiter (RFC 3986 compliant)
    const protocolMatch = url.match(/^([a-zA-Z][a-zA-Z0-9+.-]*):(.*)$/);
    if (protocolMatch) {
      protocol = protocolMatch[1].toLowerCase();
      const remainder = protocolMatch[2];

      // Check if it's a valid protocol
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }

      // Handle authority-based URIs (those with //)
      if (remainder.startsWith('//')) {
        url = remainder.substring(2);
      } else {
        // Non-authority URIs (like javascript:, data:, mailto:) should be rejected
        // unless explicitly allowed
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === '//') {
      // Protocol-relative URL
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      url = url.slice(2);
    }

This fix:
- Uses ':' as the protocol delimiter (RFC 3986 compliant)
- Validates the protocol name format (must start with letter, contain alphanumeric+.-+)
- Rejects non-authority URIs (javascript:, data:, etc.) by default
- Properly handles protocol-relative URLs (//)
- Maintains backward compatibility for legitimate HTTP/HTTPS/FTP URLs
`);

console.log('\n5. SECURITY RECOMMENDATIONS');
console.log('=' .repeat(80));
console.log(`
1. Apply the fix to use ':' as protocol delimiter
2. Add explicit blocklist for dangerous protocols:
   - javascript:, data:, vbscript:, about:, blob:
3. Add comprehensive test cases for XSS vectors
4. Consider defaulting to rejecting non-authority URIs
5. Document the security implications in the README
6. Issue a security advisory (CVE-2025-56200)
`);
