// Test script to demonstrate CVE-2025-56200 vulnerability
const validator = require('./validator');

console.log('Testing CVE-2025-56200 - Protocol Parsing Vulnerability\n');
console.log('=' .repeat(70));

// Test cases that exploit the vulnerability
const testCases = [
  { url: 'javascript:alert(1)', description: 'Basic javascript: protocol' },
  { url: 'javascript:alert(document.cookie)', description: 'XSS payload' },
  { url: 'data:text/html,<script>alert(1)</script>', description: 'Data URI XSS' },
  { url: 'vbscript:msgbox(1)', description: 'VBScript protocol (IE)' },
  { url: 'file:///etc/passwd', description: 'File protocol' },
  { url: 'javascript://example.com', description: 'javascript: with //' },
  { url: 'data://example.com', description: 'data: with //' },
  { url: 'http://example.com', description: 'Legitimate HTTP URL' },
  { url: 'https://example.com', description: 'Legitimate HTTPS URL' },
  { url: 'ftp://example.com', description: 'Legitimate FTP URL' },
];

console.log('\nDefault validation (http, https, ftp protocols):');
console.log('-' .repeat(70));

testCases.forEach(({ url, description }) => {
  const result = validator.isURL(url);
  const status = result ? '✓ PASS (VULNERABLE!)' : '✗ FAIL (correctly blocked)';
  console.log(`${status.padEnd(30)} ${url.padEnd(40)} - ${description}`);
});

console.log('\n\nWith require_valid_protocol: false (allows any protocol):');
console.log('-' .repeat(70));

testCases.forEach(({ url, description }) => {
  const result = validator.isURL(url, { require_valid_protocol: false });
  const status = result ? '✓ PASS (VULNERABLE!)' : '✗ FAIL (correctly blocked)';
  console.log(`${status.padEnd(30)} ${url.padEnd(40)} - ${description}`);
});

console.log('\n\nExplanation of the vulnerability:');
console.log('=' .repeat(70));
console.log(`
The isURL() function uses '://' as a delimiter to split the protocol:
  Line 86: split = url.split('://');

This means:
- 'javascript:alert(1)' → split.length = 1 (no '://')
  → No protocol detected, treated as path/host
- 'javascript://alert(1)' → split.length = 2 (has '://')
  → Protocol 'javascript' is extracted

However, browsers parse URLs using ':' as the protocol delimiter:
- 'javascript:alert(1)' → Browser sees 'javascript:' as protocol
- 'data:text/html,<script>' → Browser sees 'data:' as protocol

This mismatch allows attackers to bypass validation:
1. validator.js sees no protocol (no '://')
2. Browser interprets it as dangerous protocol
3. XSS or other attacks become possible
`);
